<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Task>
 */
class TaskFactory extends Factory
{
    /**
     * Define the model's default state.
     * Define el estado por defecto del modelo.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        $project = \App\Models\Project::factory()->create();

        return [
            'team_id' => $project->team_id,
            'project_id' => $project->id,
            'creator_id' => \App\Models\User::factory(),
            'key' => '', // Will be generated by Sequence / Será generado por Sequence
            'title' => fake()->sentence(4),
            'description' => fake()->paragraph(),
            'status' => fake()->randomElement(['todo', 'in_progress', 'in_review', 'done']),
            'priority' => fake()->randomElement(['lowest', 'low', 'medium', 'high', 'highest']),
            'type' => fake()->randomElement(['task', 'bug', 'feature', 'epic', 'story']),
            'story_points' => fake()->optional()->numberBetween(1, 13),
            'due_date' => fake()->optional()->dateTimeBetween('now', '+1 month'),
            'started_at' => fake()->optional()->dateTimeBetween('-1 week', 'now'),
            'completed_at' => null,
            'position' => fake()->numberBetween(0, 100),
            'metadata' => [
                'estimated_hours' => fake()->optional()->numberBetween(1, 40),
                'tags' => fake()->words(3),
            ],
        ];
    }

    /**
     * Configure the model factory.
     * Configura la factoría del modelo.
     */
    public function configure(): static
    {
        return $this->afterMaking(function (\App\Models\Task $task) {
            // Generate sequential task key based on project / Generar clave secuencial de tarea basada en proyecto
            if (empty($task->key) && $task->project_id) {
                $project = \App\Models\Project::find($task->project_id);
                if ($project) {
                    // Get next task number for this project / Obtener siguiente número de tarea para este proyecto
                    // Use max to handle concurrent creation / Usar max para manejar creación concurrente
                    $maxTaskNumber = \App\Models\Task::where('project_id', $project->id)
                        ->where('key', 'like', $project->key . '-%')
                        ->get()
                        ->map(function ($t) use ($project) {
                            $parts = explode('-', $t->key);
                            return isset($parts[1]) ? (int)$parts[1] : 0;
                        })
                        ->max() ?? 0;
                    
                    $taskNumber = $maxTaskNumber + 1;
                    $task->key = $project->key . '-' . $taskNumber;
                }
            }
        });
    }

    /**
     * Indicate that the task is completed.
     * Indica que la tarea está completada.
     */
    public function completed(): static
    {
        return $this->state(function (array $attributes) {
            return [
                'status' => 'done',
                'completed_at' => fake()->dateTimeBetween($attributes['created_at'] ?? '-1 week', 'now'),
            ];
        });
    }

    /**
     * Indicate that the task is in progress.
     * Indica que la tarea está en progreso.
     */
    public function inProgress(): static
    {
        return $this->state(fn (array $attributes) => [
            'status' => 'in_progress',
            'started_at' => fake()->dateTimeBetween('-1 week', 'now'),
        ]);
    }
}
